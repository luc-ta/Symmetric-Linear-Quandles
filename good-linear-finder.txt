local n, k, d, FixList, kInv, orbitOf, listOfOrbits, ell, m, a, alreadyInOrbit, currentOrbit, solnsCount, testPsiLocalCandidate, psiLocalCandidate, psi, x, psiArg, isGood, rho, v, i, recursionDepth, orbitSoFar, orbitSet, smOfX, smInvOfX, depthOfBFS;

# recursively test functions psi: (Z/nZ)/Inn Q -> Fix(phi_k)
	testPsiLocalCandidate := function(recursionDepth, psiLocalCandidate)
        local currentOrbit, v, i, psi, x, psiArg, isGood, rho, invol;
        if recursionDepth > Length(listOfOrbits) then
			# construct psi as an array indexed by x+1
			psi := [];
			for i in [1..Length(listOfOrbits)] do
				currentOrbit := listOfOrbits[i];
				for x in currentOrbit do psi[x+1] := psiLocalCandidate[i]; od;
			od;

			# Does psi satisfy the equality psi(x) = psi(psi(x) - kx)?
			isGood := true;
			for x in [0..n-1] do
				psiArg := (psi[x+1] - k*x) mod n;
				if psi[x+1] <> psi[psiArg+1] then isGood := false; break; fi;
			od;

			if isGood then
				# print what rho actually is
				rho := [];
				for x in [0..n-1] do rho[x+1] := (psi[x+1] - k*x) mod n; od;
				# print rho (images of 0..n-1)
				Print("Solution for n=",n,", k=",k,", d=",d,": rho = [");
				for x in [0..n-1] do
					if x <> 0 then Print(", "); fi;
					Print(rho[x+1]);
				od;
				Print("]\n");

				solnsCount := solnsCount + 1;
			fi;

			return;
        fi;

        for v in FixList do
			psiLocalCandidate[recursionDepth] := v;
			testPsiLocalCandidate(recursionDepth+1, psiLocalCandidate);
        od;
    end;
	  
    # compute the listOfOrbits of Z/nZ under the action of Inn Q using an exhaustive, BFS-like search
    orbitOf := function(a)
        local seenYet, orbitSoFar, depthOfBFS, x, m, smOfX, smInvOfX;
		# seenYet[i+1] = true if and only if we've seen i already
        seenYet := List([0..n-1], i -> false);
        orbitSoFar := [a];
        depthOfBFS := 1;
        while depthOfBFS <= Length(orbitSoFar) do
			x := orbitSoFar[depthOfBFS];
			depthOfBFS := depthOfBFS + 1;
			for m in [0..n-1] do
			# compute image of x under the inner automorphism s_m and its inverse
				smOfX := (k*x - (k-1)*m) mod n;
				if not seenYet[smOfX+1] then
					seenYet[smOfX+1] := true;
					Add(orbitSoFar, smOfX);
				fi;
				smInvOfX := (kInv*(x + (k-1)*m)) mod n;
				if not seenYet[smInvOfX+1] then
					seenYet[smInvOfX+1] := true;
					Add(orbitSoFar, smInvOfX);
				fi;
			od;
        od;
        return orbitSoFar;
    end;

# Main routine: Find all functions psi: (Z/nZ)/Inn Q -> Fix_k satisfying psi(x) = psi(psi(x) - kx)
# For each order n >= 3 and each element k having order 2 in (Z/nZ)^x:
#  - compute d = gcd(n,k-1) and Fix_k = <n/d> (= Z/dZ)
#  - construct the inner automorphisms s_m(x) = kx - (k-1)m and their inverses for all m = 0..n-1
#  - compute listOfOrbits = (Z/nZ)/Inn Q
#  - for each psi satisfying the above, record the good involution rho(x)=psi(x)-kx

for n in [3..9] do # change orders as desired
	Print("\n=== n = ", n, " ===\n");
	for k in [1..n-1] do
		if Gcd(k,n) = 1 and (k*k) mod n = 1 and k mod n <> 1 then
			# k is a unit of order 1 or 2; we exclude k=1 so this is order 2
			d := Gcd(n, k-1);
			# list of elements of Fix_k (as integers 0..n-1)
			FixList := List([0..d-1], ell -> (ell*(n/d)) mod n);

			# find inverse of k mod n by brute force
			for ell in [1..n-1] do
				if (k*ell) mod n = 1 then kInv := ell; break; fi;
			od;

			# compute all listOfOrbits
			listOfOrbits := [];
			for a in [0..n-1] do
				# Is a already in an orbit?
				alreadyInOrbit := false;
				for currentOrbit in listOfOrbits do
					if a in currentOrbit then alreadyInOrbit := true; break; fi;
				od;
				if not alreadyInOrbit then
					Add(listOfOrbits, orbitOf(a));
				fi;
			od;

			# solnsCount solutions psi
			solnsCount := 0;

			testPsiLocalCandidate(1, List([1..Length(listOfOrbits)], i -> 0));

			if solnsCount > 0 then
				Print("Total solutions for n=",n,", k=",k,": ", solnsCount, "\n");
			else
				Print("No solutions for n=",n,", k=",k,"\n");
			fi;
		fi;
	od;
od;
